// This file is auto-generated by scripts/generate-templates.js
// Do not edit manually! Edit the markdown files in templates/ instead.

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export interface ManifestOptions {
  dir: string;
  minimal: boolean;
}

export interface RuleDefinition {
  id: string;
  filename: string;
  minimal: boolean;
  modes: string[];
}

export interface RuleTemplate {
  filename: string;
  content: string;
}

// ============================================================================
// EMBEDDED TEMPLATES
// ============================================================================

const security_md = "# Security\n\n## Purpose\n\nDefine security expectations for AI-generated code in this repo.\n\n## Do\n\n- **Never commit secrets** – no API keys, tokens, passwords in code or logs\n- **Validate all inputs** – especially user-provided data, query params, form fields\n- **Use environment variables** for secrets (e.g., `.env` files, not committed)\n- **Sanitize outputs** – prevent XSS, SQL injection, command injection\n- **Follow least privilege** – grant minimal necessary permissions\n- **Keep dependencies updated** – regularly audit and update packages\n- **Use secure defaults** – HTTPS, secure cookies, strong crypto\n- **Log security events** – failed auth attempts, suspicious activity (without logging sensitive data)\n\n## Don't\n\n- **Don't hardcode credentials** – ever\n- **Don't trust user input** – always validate and sanitize\n- **Don't use weak crypto** – no MD5, SHA1 for passwords; use bcrypt, argon2, or scrypt\n- **Don't expose stack traces** – in production error messages\n- **Don't add risky dependencies casually** – vet packages before installing\n- **Don't skip security headers** – CSP, HSTS, X-Frame-Options, etc.\n\n## Examples\n\n### ✅ Good: Environment variables\n\n```javascript\nconst apiKey = process.env.API_KEY;\nif (!apiKey) {\n  throw new Error(\"API_KEY not configured\");\n}\n```\n\n### ❌ Bad: Hardcoded secret\n\n```javascript\nconst apiKey = \"sk-1234567890abcdef\"; // NEVER do this\n```\n\n### ✅ Good: Input validation\n\n```javascript\nfunction getUser(userId) {\n  if (!/^[0-9]+$/.test(userId)) {\n    throw new Error(\"Invalid user ID\");\n  }\n  return db.query(\"SELECT * FROM users WHERE id = ?\", [userId]);\n}\n```\n\n### ❌ Bad: SQL injection risk\n\n```javascript\nfunction getUser(userId) {\n  return db.query(`SELECT * FROM users WHERE id = ${userId}`); // vulnerable\n}\n```\n";

const unit_tests_md = "# Unit Tests\n\n## Purpose\n\nDefine how AI should write and maintain unit tests in this repo.\n\n## Do\n\n- **Update tests when behavior changes** – tests should reflect current expected behavior\n- **Cover edge cases** – empty inputs, null, undefined, boundary values\n- **Test error paths** – not just happy paths\n- **Use descriptive test names** – `it('should return 404 when user not found')`\n- **Keep tests fast** – mock external dependencies (APIs, databases)\n- **Test one thing per test** – focused assertions\n- **Use test fixtures** – reusable test data\n- **Assert meaningful outputs** – not just \"doesn't crash\"\n\n## Don't\n\n- **Don't test implementation details** – test behavior, not private methods\n- **Don't write flaky tests** – avoid timeouts, race conditions\n- **Don't skip failing tests** – fix or remove them\n- **Don't copy-paste tests** – extract shared setup\n- **Don't mock everything** – test real logic when possible\n- **Don't ignore test failures** – they indicate real issues\n\n## Examples\n\n### ✅ Good: Behavior-focused test\n\n```javascript\ndescribe(\"UserService\", () => {\n  it(\"should throw error when creating user with duplicate email\", async () => {\n    await createUser({ email: \"test@example.com\" });\n\n    await expect(createUser({ email: \"test@example.com\" })).rejects.toThrow(\n      \"Email already exists\",\n    );\n  });\n});\n```\n\n### ✅ Good: Edge case coverage\n\n```javascript\ndescribe(\"calculateDiscount\", () => {\n  it(\"should return 0 for negative prices\", () => {\n    expect(calculateDiscount(-10)).toBe(0);\n  });\n\n  it(\"should return 0 for null price\", () => {\n    expect(calculateDiscount(null)).toBe(0);\n  });\n\n  it(\"should handle zero price\", () => {\n    expect(calculateDiscount(0)).toBe(0);\n  });\n});\n```\n\n### ❌ Bad: Testing implementation details\n\n```javascript\nit(\"should call internal _parseData method\", () => {\n  const spy = jest.spyOn(service, \"_parseData\");\n  service.process(data);\n  expect(spy).toHaveBeenCalled(); // testing internals, not behavior\n});\n```\n";

const naming_md = "# Naming Conventions\n\n## Purpose\n\nDefine naming standards for consistency across the codebase.\n\n## Do\n\n- **Use descriptive names** – `getUserById` not `get`\n- **Follow language conventions** – camelCase for JS/TS, snake_case for Python\n- **Be consistent** – if the repo uses `fetch*`, don't add `get*` functions\n- **Use plural for collections** – `users`, `items`\n- **Use verb-noun for functions** – `createUser`, `deletePost`\n- **Use clear boolean names** – `isActive`, `hasPermission`, `canEdit`\n- **Avoid abbreviations** – unless widely known (HTTP, API, ID)\n- **Match domain language** – use terms from the product/business\n\n## Don't\n\n- **Don't be cryptic** – `a`, `tmp`, `data2`\n- **Don't use misleading names** – `get*` should not modify state\n- **Don't mix conventions** – pick one and stick with it\n- **Don't use generic names** – `handler`, `manager`, `helper` without context\n- **Don't overuse prefixes** – `myFunction`, `theVariable`\n\n## Examples\n\n### ✅ Good: Clear function names\n\n```javascript\nfunction createUser(userData) {}\nfunction deletePost(postId) {}\nfunction isAuthenticated(user) {}\n```\n\n### ❌ Bad: Vague names\n\n```javascript\nfunction process(d) {} // what does this do?\nfunction handle() {} // handle what?\nfunction doStuff() {} // too generic\n```\n\n### ✅ Good: Descriptive variables\n\n```javascript\nconst activeUsers = users.filter((u) => u.isActive);\nconst maxRetries = 3;\nconst apiBaseUrl = \"https://api.example.com\";\n```\n\n### ❌ Bad: Unclear variables\n\n```javascript\nconst arr = users.filter((u) => u.isActive); // what kind of array?\nconst num = 3; // what number?\nconst url = \"https://api.example.com\"; // which URL?\n```\n\n### ✅ Good: Boolean naming\n\n```javascript\nconst isLoading = true;\nconst hasPermission = user.role === \"admin\";\nconst canDelete = isOwner || isAdmin;\n```\n\n### ❌ Bad: Unclear booleans\n\n```javascript\nconst loading = true;      // could be a loading indicator element\nconst permission = true;   // which permission?\nconst delete = true;       // \"delete\" is ambiguous\n```\n";

const architecture_md = "# Architecture\n\n## Purpose\n\nDefine architectural patterns and organization principles for this repo.\n\n## Do\n\n- **Follow existing patterns** – if the repo has a structure, maintain it\n- **Put code in the right place** – controllers, services, models, utils\n- **Reuse existing utilities** – check before creating new helper functions\n- **Keep modules focused** – single responsibility principle\n- **Minimize dependencies** – between modules\n- **Document architecture decisions** – why, not just what\n- **Use dependency injection** – for testability\n- **Separate concerns** – business logic, data access, presentation\n\n## Don't\n\n- **Don't create new patterns** – without justification or discussion\n- **Don't duplicate functionality** – search for existing solutions first\n- **Don't tightly couple modules** – avoid circular dependencies\n- **Don't mix layers** – keep business logic out of controllers\n- **Don't bypass abstractions** – use the data layer, don't query directly\n- **Don't ignore folder structure** – respect the repo's organization\n\n## Examples\n\n### ✅ Good: Layered architecture\n\n```javascript\n// controller/userController.js\nexport async function getUser(req, res) {\n  const user = await userService.findById(req.params.id);\n  res.json(user);\n}\n\n// service/userService.js\nexport async function findById(id) {\n  return userRepository.findById(id);\n}\n\n// repository/userRepository.js\nexport async function findById(id) {\n  return db.query(\"SELECT * FROM users WHERE id = ?\", [id]);\n}\n```\n\n### ❌ Bad: Mixed concerns\n\n```javascript\n// controller/userController.js\nexport async function getUser(req, res) {\n  // Don't put database queries directly in controllers\n  const user = await db.query(\"SELECT * FROM users WHERE id = ?\", [\n    req.params.id,\n  ]);\n  res.json(user);\n}\n```\n\n### ✅ Good: Reusing utilities\n\n```javascript\nimport { formatDate } from \"../utils/date\";\nimport { validateEmail } from \"../utils/validation\";\n\nconst formattedDate = formatDate(user.createdAt);\n```\n\n### ❌ Bad: Duplicating utilities\n\n```javascript\n// Creating new date formatting when one exists\nfunction myDateFormatter(date) {\n  // duplicates existing formatDate utility\n}\n```\n";

const performance_md = "# Performance\n\n## Purpose\n\nDefine performance expectations and optimization guidelines for AI-generated code.\n\n## Do\n\n- **Measure before optimizing** – use profilers and benchmarks\n- **Use appropriate data structures** – Map for lookups, Set for uniqueness, Array for ordered data\n- **Cache expensive operations** – memoize, cache API calls, precompute when possible\n- **Avoid unnecessary re-renders** – React.memo, useMemo, useCallback where appropriate\n- **Lazy load when possible** – code splitting, dynamic imports, lazy components\n- **Optimize loops** – avoid nested loops with large datasets, use early returns\n- **Use efficient algorithms** – consider Big O complexity\n- **Debounce/throttle** – for frequent events (scroll, resize, input)\n- **Optimize images** – compress, use appropriate formats, lazy load\n- **Monitor bundle size** – keep dependencies lean\n\n## Don't\n\n- **Don't premature optimize** – optimize hot paths only after measuring\n- **Don't block the main thread** – use Web Workers for heavy computation\n- **Don't fetch in loops** – batch API calls, use Promise.all\n- **Don't ignore memory leaks** – clean up event listeners, timers, subscriptions\n- **Don't load everything upfront** – use pagination, infinite scroll, virtualization\n- **Don't ignore Core Web Vitals** – LCP, FID, CLS matter for UX\n\n## Examples\n\n### ✅ Good: Memoization\n\n```javascript\nconst cache = new Map();\n\nfunction expensiveOperation(key) {\n  if (cache.has(key)) return cache.get(key);\n\n  const result = /* expensive computation */;\n  cache.set(key, result);\n  return result;\n}\n```\n\n### ❌ Bad: Repeated computation\n\n```javascript\nfunction expensiveOperation(key) {\n  return /* expensive computation every time */;\n}\n```\n\n### ✅ Good: Batch API calls\n\n```javascript\nconst userIds = [1, 2, 3, 4, 5];\nconst users = await fetchUsers(userIds); // Single request\n```\n\n### ❌ Bad: N+1 queries\n\n```javascript\nconst users = [];\nfor (const id of userIds) {\n  users.push(await fetchUser(id)); // 5 separate requests!\n}\n```\n";

const code_review_md = "# Code Review\n\n## Purpose\n\nDefine standards for code reviews and what to look for when reviewing AI-generated code.\n\n## Do\n\n- **Check for security issues** – SQL injection, XSS, hardcoded secrets\n- **Verify error handling** – proper try/catch, error messages, fallbacks\n- **Review test coverage** – edge cases covered, meaningful assertions\n- **Check naming consistency** – follows repo conventions\n- **Verify documentation** – complex logic explained, JSDoc/comments where needed\n- **Look for duplication** – reusable code extracted to functions/modules\n- **Check dependencies** – necessary, up-to-date, no suspicious packages\n- **Verify accessibility** – semantic HTML, ARIA labels, keyboard navigation\n- **Check performance** – no obvious bottlenecks, efficient algorithms\n- **Review git history** – clear commit messages, logical commits\n\n## Don't\n\n- **Don't approve blindly** – actually read and understand the changes\n- **Don't nitpick style** – let linters/formatters handle it\n- **Don't block on preferences** – focus on correctness and maintainability\n- **Don't merge with unresolved comments** – address or explicitly defer\n- **Don't skip testing** – actually run the code locally\n- **Don't assume AI is always right** – LLMs make mistakes\n\n## Examples\n\n### ✅ Good: Constructive feedback\n\n```\nThis function could throw if userId is undefined.\nConsider adding validation:\n  if (!userId) throw new Error('userId required');\n```\n\n### ❌ Bad: Vague criticism\n\n```\nThis doesn't look right\n```\n\n### ✅ Good: Security catch\n\n```\n⚠️ SQL injection risk here - use parameterized queries:\n  db.query('SELECT * FROM users WHERE id = ?', [userId])\n```\n";

const error_handling_md = "# Error Handling\n\n## Purpose\n\nDefine how errors should be handled and reported in AI-generated code.\n\n## Do\n\n- **Use try/catch for async operations** – especially API calls, file I/O\n- **Throw meaningful errors** – descriptive messages, include context\n- **Use custom error classes** – for domain-specific errors\n- **Log errors properly** – include stack traces, context, but not secrets\n- **Handle errors at appropriate level** – don't catch too early\n- **Provide fallbacks** – graceful degradation when possible\n- **Validate inputs early** – fail fast with clear errors\n- **Use error boundaries** – in React/UI frameworks\n- **Return error objects** – instead of throwing in some cases (Result pattern)\n- **Document error cases** – what exceptions can be thrown\n\n## Don't\n\n- **Don't swallow errors** – empty catch blocks hide bugs\n- **Don't expose internals** – no stack traces in production to users\n- **Don't use errors for control flow** – errors are for exceptional cases\n- **Don't log secrets** – no passwords, tokens, PII in error logs\n- **Don't ignore promise rejections** – always handle with .catch or try/catch\n- **Don't use generic messages** – \"Something went wrong\" isn't helpful\n\n## Examples\n\n### ✅ Good: Specific error with context\n\n```javascript\nasync function getUser(userId) {\n  if (!userId) {\n    throw new Error(\"userId is required\");\n  }\n\n  try {\n    return await api.fetchUser(userId);\n  } catch (error) {\n    throw new Error(`Failed to fetch user ${userId}: ${error.message}`);\n  }\n}\n```\n\n### ❌ Bad: Swallowed error\n\n```javascript\nasync function getUser(userId) {\n  try {\n    return await api.fetchUser(userId);\n  } catch (error) {\n    // Silent failure - bug is hidden!\n  }\n}\n```\n\n### ✅ Good: Error boundary (React)\n\n```javascript\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    logError(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <ErrorFallback />;\n    }\n    return this.props.children;\n  }\n}\n```\n";

const documentation_md = "# Documentation\n\n## Purpose\n\nDefine documentation standards for AI-generated code.\n\n## Do\n\n- **Document the \"why\" not the \"what\"** – code shows what, comments explain why\n- **Add JSDoc for public APIs** – parameters, return types, examples\n- **Document complex logic** – algorithms, business rules, non-obvious code\n- **Keep README updated** – installation, usage, examples\n- **Add inline comments** – for tricky parts, workarounds, TODOs\n- **Document breaking changes** – in CHANGELOG or commit messages\n- **Include examples** – especially for libraries and utilities\n- **Document edge cases** – what assumptions are made\n- **Link to related docs** – design docs, tickets, RFCs\n- **Keep docs close to code** – avoid docs getting stale\n\n## Don't\n\n- **Don't state the obvious** – `// increment i` is useless\n- **Don't let docs drift** – update docs when code changes\n- **Don't over-document** – clear code needs fewer comments\n- **Don't write novels** – be concise and clear\n- **Don't document implementation details** – unless necessary\n- **Don't use outdated examples** – test your examples\n\n## Examples\n\n### ✅ Good: Explains \"why\"\n\n```javascript\n// Using setTimeout instead of setInterval because the API call\n// can take longer than 5s, which would cause requests to queue up\nsetTimeout(() => pollAPI(), 5000);\n```\n\n### ❌ Bad: States the obvious\n\n```javascript\n// Call the API\ncallAPI();\n```\n\n### ✅ Good: JSDoc with examples\n\n```javascript\n/**\n * Formats a date for display in the UI\n * @param {Date} date - The date to format\n * @param {string} locale - The locale (e.g., 'en-US', 'es-ES')\n * @returns {string} Formatted date string\n * @example\n *   formatDate(new Date(), 'en-US') // \"Jan 1, 2024\"\n */\nfunction formatDate(date, locale) {\n  return new Intl.DateTimeFormat(locale).format(date);\n}\n```\n\n### ✅ Good: Complex logic explanation\n\n```javascript\n// We're using a binary search here because the data is sorted\n// and can be very large (100k+ items). Linear search would be O(n).\n// This gives us O(log n) performance.\nfunction binarySearch(arr, target) {\n  // ...\n}\n```\n";

const accessibility_md = "# Accessibility (a11y)\n\n## Purpose\n\nDefine accessibility standards for AI-generated UI code to ensure inclusivity.\n\n## Do\n\n- **Use semantic HTML** – `<button>`, `<nav>`, `<main>`, not just `<div>`\n- **Add ARIA labels** – when semantic HTML isn't enough\n- **Ensure keyboard navigation** – tab order, focus management, shortcuts\n- **Provide alt text** – for all images (empty alt=\"\" for decorative)\n- **Use sufficient color contrast** – WCAG AA minimum (4.5:1 for text)\n- **Make clickable areas large** – 44x44px minimum touch targets\n- **Support screen readers** – test with VoiceOver, NVDA, JAWS\n- **Add skip links** – \"Skip to main content\" for keyboard users\n- **Use labels for inputs** – properly associated with `for`/`id`\n- **Test with keyboard only** – tab, enter, escape, arrows\n\n## Don't\n\n- **Don't rely on color alone** – use icons, text, patterns too\n- **Don't use `<div>` for buttons** – use `<button>` or proper ARIA\n- **Don't auto-play media** – provide controls, respect prefers-reduced-motion\n- **Don't break zoom** – avoid `maximum-scale=1` in viewport\n- **Don't use placeholder as label** – placeholders disappear on input\n- **Don't forget focus styles** – never `outline: none` without alternative\n- **Don't hide content** – that should be available to screen readers\n\n## Examples\n\n### ✅ Good: Semantic HTML\n\n```jsx\n<button onClick={handleClick}>Delete</button>\n```\n\n### ❌ Bad: Div as button\n\n```jsx\n<div onClick={handleClick}>Delete</div>\n```\n\n### ✅ Good: Proper label\n\n```jsx\n<label htmlFor=\"email\">Email</label>\n<input id=\"email\" type=\"email\" />\n```\n\n### ❌ Bad: Placeholder as label\n\n```jsx\n<input type=\"email\" placeholder=\"Email\" />\n```\n\n### ✅ Good: Icon with label\n\n```jsx\n<button aria-label=\"Close dialog\">\n  <XIcon />\n</button>\n```\n\n### ✅ Good: Keyboard support\n\n```javascript\nfunction handleKeyDown(e) {\n  if (e.key === \"Escape\") {\n    closeModal();\n  }\n  if (e.key === \"Enter\" || e.key === \" \") {\n    handleAction();\n  }\n}\n```\n";

const api_design_md = "# API Design\n\n## Purpose\n\nDefine standards for designing APIs (REST, GraphQL, internal modules).\n\n## Do\n\n- **Use RESTful conventions** – GET (read), POST (create), PUT/PATCH (update), DELETE\n- **Version your API** – /v1/, /v2/, or header-based versioning\n- **Use plural nouns** – `/users`, `/posts`, not `/user`, `/post`\n- **Return proper HTTP status codes** – 200 success, 201 created, 400 bad request, 404 not found, 500 error\n- **Include pagination** – for list endpoints (limit, offset or cursor)\n- **Validate inputs** – return 400 with clear error messages\n- **Use consistent naming** – camelCase or snake_case, pick one\n- **Include timestamps** – createdAt, updatedAt for resources\n- **Document your API** – OpenAPI/Swagger specs\n- **Handle errors gracefully** – return error objects with code and message\n\n## Don't\n\n- **Don't use verbs in URLs** – use HTTP methods instead\n- **Don't expose internal IDs** – use UUIDs or opaque identifiers\n- **Don't return different structures** – for same endpoint in different states\n- **Don't forget rate limiting** – protect against abuse\n- **Don't expose stack traces** – in production error responses\n- **Don't break backward compatibility** – without versioning\n- **Don't use GET for mutations** – GET should be idempotent\n\n## Examples\n\n### ✅ Good: RESTful design\n\n```\nGET    /v1/users          # List users\nGET    /v1/users/123      # Get user\nPOST   /v1/users          # Create user\nPATCH  /v1/users/123      # Update user\nDELETE /v1/users/123      # Delete user\n```\n\n### ❌ Bad: Non-RESTful\n\n```\nGET  /getUsers\nPOST /createUser\nPOST /deleteUser\n```\n\n### ✅ Good: Error response\n\n```json\n{\n  \"error\": {\n    \"code\": \"INVALID_EMAIL\",\n    \"message\": \"Email address is not valid\",\n    \"field\": \"email\"\n  }\n}\n```\n\n### ❌ Bad: Vague error\n\n```json\n{\n  \"error\": \"Bad request\"\n}\n```\n\n### ✅ Good: Pagination\n\n```json\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"total\": 1000,\n    \"page\": 1,\n    \"pageSize\": 20,\n    \"totalPages\": 50\n  }\n}\n```\n";

const git_workflow_md = "# Git Workflow\n\n## Purpose\n\nDefine Git commit and branch standards for AI-generated code changes.\n\n## Do\n\n- **Write clear commit messages** – use conventional commits format\n- **Make atomic commits** – one logical change per commit\n- **Use descriptive branch names** – feature/add-login, fix/memory-leak\n- **Keep commits small** – easier to review and revert\n- **Test before committing** – ensure code works\n- **Write commit body** – for complex changes, explain why\n- **Reference issues** – \"Fixes #123\" in commit message\n- **Squash before merge** – keep main branch clean (if team convention)\n- **Pull before push** – avoid merge conflicts\n- **Use feature branches** – never commit directly to main\n\n## Don't\n\n- **Don't commit secrets** – use .gitignore, check before push\n- **Don't commit commented code** – delete it, Git has history\n- **Don't commit build artifacts** – node_modules, dist/, .env\n- **Don't use vague messages** – \"fix bug\", \"update code\"\n- **Don't commit WIP** – to shared branches\n- **Don't rewrite public history** – no force push to main/shared branches\n- **Don't make giant commits** – breaks down to reviewable chunks\n\n## Examples\n\n### ✅ Good: Conventional commit\n\n```\nfeat: add user authentication with JWT\n\nImplements login, logout, and token refresh endpoints.\nUses bcrypt for password hashing and validates tokens\non protected routes.\n\nFixes #45\n```\n\n### ❌ Bad: Vague message\n\n```\nupdated stuff\n```\n\n### ✅ Good: Branch naming\n\n```\nfeature/user-authentication\nfix/login-button-spacing\nrefactor/api-client-structure\ndocs/update-readme\n```\n\n### ❌ Bad: Branch naming\n\n```\nmy-branch\ntest\nnew-stuff\n```\n\n### Conventional Commit Types\n\n- `feat:` New feature\n- `fix:` Bug fix\n- `docs:` Documentation\n- `style:` Formatting, no code change\n- `refactor:` Code restructuring\n- `test:` Adding tests\n- `chore:` Maintenance tasks\n- `perf:` Performance improvement\n\n```\n\n```\n";

const TEMPLATES: Record<string, string> = {
  'security.md': security_md,
  'unit-tests.md': unit_tests_md,
  'naming.md': naming_md,
  'architecture.md': architecture_md,
  'performance.md': performance_md,
  'code-review.md': code_review_md,
  'error-handling.md': error_handling_md,
  'documentation.md': documentation_md,
  'accessibility.md': accessibility_md,
  'api-design.md': api_design_md,
  'git-workflow.md': git_workflow_md,
};

// ============================================================================
// RULE DEFINITIONS
// ============================================================================

const RULE_DEFINITIONS: RuleDefinition[] = [
  {
    "id": "security",
    "filename": "security.md",
    "minimal": true,
    "modes": [
      "codegen",
      "review",
      "test",
      "docs",
      "ops"
    ]
  },
  {
    "id": "unit-tests",
    "filename": "unit-tests.md",
    "minimal": true,
    "modes": [
      "codegen",
      "test"
    ]
  },
  {
    "id": "naming",
    "filename": "naming.md",
    "minimal": true,
    "modes": [
      "codegen",
      "review"
    ]
  },
  {
    "id": "architecture",
    "filename": "architecture.md",
    "minimal": false,
    "modes": [
      "codegen",
      "review",
      "ops"
    ]
  },
  {
    "id": "performance",
    "filename": "performance.md",
    "minimal": false,
    "modes": [
      "codegen",
      "review"
    ]
  },
  {
    "id": "code-review",
    "filename": "code-review.md",
    "minimal": false,
    "modes": [
      "review"
    ]
  },
  {
    "id": "error-handling",
    "filename": "error-handling.md",
    "minimal": false,
    "modes": [
      "codegen",
      "review"
    ]
  },
  {
    "id": "documentation",
    "filename": "documentation.md",
    "minimal": false,
    "modes": [
      "codegen",
      "docs"
    ]
  },
  {
    "id": "accessibility",
    "filename": "accessibility.md",
    "minimal": false,
    "modes": [
      "codegen",
      "review"
    ]
  },
  {
    "id": "api-design",
    "filename": "api-design.md",
    "minimal": false,
    "modes": [
      "codegen",
      "review",
      "ops"
    ]
  },
  {
    "id": "git-workflow",
    "filename": "git-workflow.md",
    "minimal": false,
    "modes": [
      "docs",
      "ops"
    ]
  }
];

// ============================================================================
// TEMPLATE LOADING
// ============================================================================

function loadTemplate(filename: string): string {
  const template = TEMPLATES[filename];
  if (!template) {
    throw new Error(`Template not found: ${filename}`);
  }
  return template;
}

// ============================================================================
// PUBLIC API
// ============================================================================

export function generateManifest(options: ManifestOptions): string {
  const { dir, minimal } = options;
  
  // Filter rules based on minimal flag
  const activeRules = RULE_DEFINITIONS.filter(rule => 
    minimal ? rule.minimal : true
  );
  
  // Generate rules section
  const rules = activeRules
    .map(rule => `  ${rule.id}: "${dir}/${rule.filename}"`)
    .join('\n');
  
  // Generate order section
  const order = activeRules
    .map(rule => `  - ${rule.id}`)
    .join('\n');
  
  // Generate modes section
  const modeNames = ['codegen', 'review', 'test', 'docs', 'ops'];
  const modesSection = modeNames
    .map(modeName => {
      const rulesForMode = activeRules
        .filter(rule => rule.modes.includes(modeName))
        .map(rule => rule.id);
      
      return `  ${modeName}:\n    include: [${rulesForMode.join(', ')}]`;
    })
    .join('\n');

  return `version: 1

about:
  name: "Repo Vibes"
  description: "How AIs should work in this repo"

rules:
${rules}

order:
${order}

modes:
${modesSection}
`;
}

export function getRuleTemplates(minimal: boolean): RuleTemplate[] {
  return RULE_DEFINITIONS
    .filter(rule => minimal ? rule.minimal : true)
    .map(rule => ({
      filename: rule.filename,
      content: loadTemplate(rule.filename),
    }));
}
